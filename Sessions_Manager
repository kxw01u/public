import sys
import os
import csv
import json
import uuid
import shutil
import subprocess
import webbrowser
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QTreeWidget, QTreeWidgetItem,
    QVBoxLayout, QHBoxLayout, QStyledItemDelegate, QLineEdit, QComboBox,
    QPushButton, QMessageBox, QColorDialog, QAbstractItemView, QStyle,
    QHeaderView, QStyleOptionViewItem, QFileDialog, QStyleOptionHeader,
    QDialog, QGridLayout, QLabel, QTabWidget, QDialogButtonBox, QMenu,
    QFrame, QTreeWidgetItemIterator, QTextEdit
)
from PyQt6.QtGui import (
    QColor, QBrush, QPen, QIcon, QPixmap, QAction, QGuiApplication, QPainter, QFont, QPalette
)
from PyQt6.QtCore import (
    Qt, QSize, pyqtSignal, QRect, QMimeData, QByteArray, QPoint
)

# --- CONFIGURATION ---
DATA_FILE_NAME = "Sessions_keeper.csv"
DATA_FILE = os.path.join(os.getcwd(), DATA_FILE_NAME)
SETTINGS_FILE = os.path.join(os.getcwd(), "settings.json")
CUSTOM_ICON_DIR = "user_icons"
PUTTY_PATH = "C:\\Program Files\\PuTTY\\putty.exe"
ROW_HEIGHT = 32

# --- COLUMN DEFINITIONS (CONSOLIDATED) ---
COL_ICON = 0
COL_TITLE = 1
COL_TYPE = 2
COL_ENV = 3
COL_DEST = 4
COL_PORT = 5
COL_LOGIN = 6
COL_PASSWORD = 7
COL_PATH = 8
COL_NOTE = 9
COL_ACTIONS = 10  # Consolidated: Dup, Up, Down, Del, C1, C2
COL_ACT_RUN = 11  # Run Action (Rightmost)
COL_COUNT = 12

# Data Roles (Stored on Column 0)
ROLE_ID = Qt.ItemDataRole.UserRole + 1
ROLE_C1 = Qt.ItemDataRole.UserRole + 2
ROLE_C2 = Qt.ItemDataRole.UserRole + 3
ROLE_ICON_PATH = Qt.ItemDataRole.UserRole + 4

# --- HELPER: CHECK ICONS ---
HAS_QTA = False
try:
    import qtawesome as qta

    HAS_QTA = True
except ImportError:
    pass


def get_icon(name, color, fallback_std):
    """Returns qtawesome icon if available, else standard PyQt icon."""
    if HAS_QTA:
        return qta.icon(name, color=color)
    else:
        return QApplication.style().standardIcon(fallback_std)


# --- DIALOGS ---

class NoteDialog(QDialog):
    """Dialog for editing multi-line notes."""

    def __init__(self, text="", parent=None):
        super().__init__(parent)
        self.setWindowTitle("Edit Note")
        self.resize(400, 300)
        self.layout = QVBoxLayout(self)

        self.label = QLabel("Enter note (multiple lines allowed):")
        self.layout.addWidget(self.label)

        self.text_edit = QTextEdit()
        self.text_edit.setPlainText(text)
        self.layout.addWidget(self.text_edit)

        btns = QDialogButtonBox(QDialogButtonBox.StandardButton.Ok | QDialogButtonBox.StandardButton.Cancel)
        btns.accepted.connect(self.accept)
        btns.rejected.connect(self.reject)
        self.layout.addWidget(btns)

    def get_text(self):
        return self.text_edit.toPlainText()


# --- CUSTOM TREE WIDGET ---
class SessionTreeWidget(QTreeWidget):
    """Custom Tree Widget to handle clicks on empty space and drops."""

    # Signal emitted when an item is dropped
    itemsDropped = pyqtSignal()

    def mousePressEvent(self, event):
        # Check if the click is on an item
        item = self.itemAt(event.pos())
        if not item:
            # Clicked on empty space, clear selection
            self.clearSelection()

        # Pass the event to the parent class for standard handling
        super().mousePressEvent(event)

    def dropEvent(self, event):
        # Perform standard drop
        super().dropEvent(event)
        # Emit signal to reload buttons
        self.itemsDropped.emit()


# --- DELEGATE (RENDERING & EDITING) ---
class SessionDelegate(QStyledItemDelegate):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.session_types = ["", "Group", "SSH", "TELNET", "PASSWORD", "WEB", "APP"]
        self.env_types = ["", "PROD", "UAT"]

    def initStyleOption(self, option, index):
        super().initStyleOption(option, index)
        # MASK PASSWORD IN DISPLAY MODE
        if index.column() == COL_PASSWORD:
            text = index.data(Qt.ItemDataRole.DisplayRole)
            if text:
                option.text = "â—" * 8

        # NOTE abbreviation
        if index.column() == COL_NOTE:
            text = index.data(Qt.ItemDataRole.DisplayRole)
            if text:
                if "\n" in text:
                    option.text = text.split("\n")[0] + "..."
                else:
                    option.text = text

    def createEditor(self, parent, option, index):
        col = index.column()
        # No editors for Icon, Actions, Run, Note
        if col == COL_ICON or col >= COL_ACTIONS or col == COL_NOTE:
            return None

        # Logic: If Group, only edit Title/Type/Env
        type_item = index.siblingAtColumn(COL_TYPE)
        type_text = type_item.data(Qt.ItemDataRole.DisplayRole)

        if type_text == "Group" and col not in (COL_TITLE, COL_TYPE, COL_ENV):
            return None

        if col == COL_TYPE:
            cb = QComboBox(parent)
            cb.addItems(self.session_types)
            return cb
        elif col == COL_ENV:
            cb = QComboBox(parent)
            cb.addItems(self.env_types)
            return cb
        elif col == COL_PASSWORD:
            le = QLineEdit(parent)
            le.setEchoMode(QLineEdit.EchoMode.Normal)
            return le

        return super().createEditor(parent, option, index)

    def setEditorData(self, editor, index):
        if isinstance(editor, QComboBox):
            text = index.data(Qt.ItemDataRole.DisplayRole)
            idx = editor.findText(text)
            if idx >= 0: editor.setCurrentIndex(idx)
        else:
            super().setEditorData(editor, index)

    def setModelData(self, editor, model, index):
        if isinstance(editor, QComboBox):
            model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)
        else:
            super().setModelData(editor, model, index)

    def paint(self, painter, option, index):
        col = index.column()
        painter.save()

        # 1. Backgrounds
        # Utility columns (Icon, Actions, Run) get flat white background
        is_utility = (col == COL_ICON or col >= COL_ACTIONS)

        opt = QStyleOptionViewItem(option)
        if is_utility:
            opt.state &= ~QStyle.StateFlag.State_Selected
            opt.state &= ~QStyle.StateFlag.State_HasFocus
            painter.fillRect(option.rect, Qt.GlobalColor.white)
        else:
            # For data columns, apply row colors if defined
            # Fetch C1 from Column 0 (Icon column where we stored data)
            c1 = index.siblingAtColumn(0).data(ROLE_C1)
            if c1:
                painter.fillRect(option.rect, QColor(c1))

            # Draw Selection Border
            if option.state & QStyle.StateFlag.State_Selected:
                pen = QPen(option.palette.highlight().color(), 2)
                r = option.rect.adjusted(1, 1, -2, -2)
                painter.setPen(pen)
                painter.drawRect(r)

        # 2. Content
        if col == COL_ICON:
            icon_path = index.data(ROLE_ICON_PATH)
            icon = self._resolve_icon(icon_path)
            if icon:
                size = 16
                x = option.rect.center().x() - size // 2
                y = option.rect.center().y() - size // 2
                painter.drawPixmap(x, y, icon.pixmap(size, size))

        elif col == COL_PASSWORD:
            super().paint(painter, opt, index)

        elif col == COL_NOTE:
            super().paint(painter, opt, index)

        elif col < COL_ACTIONS:
            # TEXT COLOR LOGIC
            # 1. Default to user-set C2 color for the row (stored in col 0)
            c2_val = index.siblingAtColumn(0).data(ROLE_C2)
            if c2_val:
                opt.palette.setColor(QPalette.ColorRole.Text, QColor(c2_val))

            # 2. Special override ONLY for Env column
            if col == COL_ENV:
                env_val = index.data(Qt.ItemDataRole.DisplayRole)
                if env_val == "PROD":
                    opt.palette.setColor(QPalette.ColorRole.Text, QColor("red"))
                elif env_val == "UAT":
                    opt.palette.setColor(QPalette.ColorRole.Text, QColor("blue"))

            # Bold Group rows
            type_val = index.siblingAtColumn(COL_TYPE).data(Qt.ItemDataRole.DisplayRole)
            if type_val == "Group":
                opt.font.setBold(True)

            super().paint(painter, opt, index)

        # 3. Grid Lines
        painter.setPen(QPen(QColor("#e0e0e0")))
        painter.drawLine(option.rect.bottomLeft(), option.rect.bottomRight())
        painter.drawLine(option.rect.topRight(), option.rect.bottomRight())

        painter.restore()

    def _resolve_icon(self, path):
        if not path: return None
        if path.startswith("std_"):
            try:
                val = int(path.split("_")[1])
                return QApplication.style().standardIcon(QStyle.StandardPixmap(val))
            except:
                return None
        elif path.startswith("custom|"):
            fname = path.split("|")[1]
            fpath = os.path.join(CUSTOM_ICON_DIR, fname)
            if os.path.exists(fpath):
                return QIcon(fpath)
        return None


# --- ICON PICKER DIALOG ---
class IconPickerDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Icon")
        self.setFixedSize(500, 400)
        self.result_icon = None

        if not os.path.exists(CUSTOM_ICON_DIR): os.makedirs(CUSTOM_ICON_DIR)

        layout = QVBoxLayout(self)
        tabs = QTabWidget()
        self.std_tab = QWidget()
        self.cust_tab = QWidget()

        tabs.addTab(self.std_tab, "Standard")
        tabs.addTab(self.cust_tab, "Custom")
        layout.addWidget(tabs)

        self._setup_std()
        self._setup_cust()

    def _setup_std(self):
        grid = QGridLayout(self.std_tab)
        icons = [
            QStyle.StandardPixmap.SP_DirIcon,
            QStyle.StandardPixmap.SP_ComputerIcon,
            QStyle.StandardPixmap.SP_DriveHDIcon,
            QStyle.StandardPixmap.SP_DriveNetIcon,
            QStyle.StandardPixmap.SP_FileIcon,
            QStyle.StandardPixmap.SP_DesktopIcon,
            QStyle.StandardPixmap.SP_TrashIcon,
            QStyle.StandardPixmap.SP_MediaPlay,
            QStyle.StandardPixmap.SP_TitleBarMaxButton,
            QStyle.StandardPixmap.SP_MessageBoxInformation,
            QStyle.StandardPixmap.SP_ArrowUp,
            QStyle.StandardPixmap.SP_ArrowDown,
            QStyle.StandardPixmap.SP_ArrowLeft,
            QStyle.StandardPixmap.SP_ArrowRight,
            QStyle.StandardPixmap.SP_BrowserReload,
            QStyle.StandardPixmap.SP_DialogOkButton,
            QStyle.StandardPixmap.SP_DialogCancelButton,
            QStyle.StandardPixmap.SP_DialogHelpButton,
            QStyle.StandardPixmap.SP_DialogSaveButton,
            QStyle.StandardPixmap.SP_DialogCloseButton,
            QStyle.StandardPixmap.SP_DirClosedIcon,
            QStyle.StandardPixmap.SP_DirOpenIcon,
            QStyle.StandardPixmap.SP_DriveCDIcon,
            QStyle.StandardPixmap.SP_DriveDVDIcon,
            QStyle.StandardPixmap.SP_FileDialogInfoView,
            QStyle.StandardPixmap.SP_FileDialogDetailedView,
            QStyle.StandardPixmap.SP_FileDialogListView,
            QStyle.StandardPixmap.SP_ToolBarHorizontalExtensionButton,
            QStyle.StandardPixmap.SP_ToolBarVerticalExtensionButton,
            QStyle.StandardPixmap.SP_MessageBoxCritical
        ]

        cols = 6
        for i, ic in enumerate(icons):
            btn = QPushButton()
            btn.setIcon(self.style().standardIcon(ic))
            btn.setFixedSize(32, 32)
            btn.setToolTip(str(ic).split('.')[-1])
            btn.clicked.connect(lambda _, x=f"std_{ic.value}": self._finish(x))
            grid.addWidget(btn, i // cols, i % cols)

    def _setup_cust(self):
        self.cust_layout = QGridLayout(self.cust_tab)
        self._refresh_cust()

    def _refresh_cust(self):
        while self.cust_layout.count():
            item = self.cust_layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()

        add_btn = QPushButton("+")
        add_btn.setFixedSize(32, 32)
        add_btn.clicked.connect(self._upload)
        self.cust_layout.addWidget(add_btn, 0, 0)

        files = [f for f in os.listdir(CUSTOM_ICON_DIR) if f.lower().endswith(('.png', '.ico', '.jpg'))]
        for i, f in enumerate(files[:25]):
            path = os.path.join(CUSTOM_ICON_DIR, f)
            btn = QPushButton()
            btn.setIcon(QIcon(path))
            btn.setFixedSize(32, 32)
            btn.clicked.connect(lambda _, x=f"custom|{f}": self._finish(x))
            r, c = (i + 1) // 6, (i + 1) % 6
            self.cust_layout.addWidget(btn, r, c)

    def _upload(self):
        path, _ = QFileDialog.getOpenFileName(self, "Image", "", "Images (*.png *.ico *.jpg)")
        if path:
            dest = os.path.join(CUSTOM_ICON_DIR, os.path.basename(path))
            shutil.copy(path, dest)
            self._refresh_cust()

    def _finish(self, val):
        self.result_icon = val
        self.accept()


# --- MAIN WINDOW ---
class SessionKeeperApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Session Keeper V3.0 (Revamped)")
        self.setGeometry(100, 100, 1600, 700)

        self.central = QWidget()
        self.setCentralWidget(self.central)
        self.layout = QVBoxLayout(self.central)

        self._init_ui()
        self._load_data()
        self._load_settings()

    def _init_ui(self):
        # Toolbar
        tb = QHBoxLayout()

        b_grp = self._mk_btn("+ Group", "#ff9800", lambda: self.add_item(is_group=True))
        b_sess = self._mk_btn("+ Session", "#2196f3", lambda: self.add_item(is_group=False))
        b_imp = self._mk_btn("Import", "#9c27b0", self.import_csv)
        b_exp = self._mk_btn("Export", "#00bcd4", self.export_csv)
        b_save = self._mk_btn("Save", "#4caf50", self.save_data)

        tb.addWidget(b_grp)
        tb.addWidget(b_sess)
        tb.addSpacing(20)
        tb.addWidget(b_imp)
        tb.addWidget(b_exp)
        tb.addStretch()
        tb.addWidget(b_save)

        self.layout.addLayout(tb)

        # Tree - Using Custom Class
        self.tree = SessionTreeWidget()
        self.tree.setColumnCount(COL_COUNT)
        self.tree.setHeaderLabels(
            ["", "Title", "Type", "Env", "Destination", "Port", "Login", "Password", "Path", "Note",
             "Actions", "Run"])

        # Header setup
        # Standard QHeaderView used now to fix resizing issues with Run column
        header = self.tree.header()

        # Don't let last section stretch automatically, allows Run column to be manual
        header.setStretchLastSection(False)

        # Sizing
        self.tree.setColumnWidth(COL_ICON, 70)
        self.tree.setColumnWidth(COL_TITLE, 150)
        self.tree.setColumnWidth(COL_TYPE, 80)
        self.tree.setColumnWidth(COL_ENV, 70)
        self.tree.setColumnWidth(COL_DEST, 140)
        self.tree.setColumnWidth(COL_PORT, 60)
        self.tree.setColumnWidth(COL_NOTE, 150)
        self.tree.setColumnWidth(COL_ACTIONS, 200)  # Consolidated width
        self.tree.setColumnWidth(COL_ACT_RUN, 60)

        # Interactive resizing
        header.setSectionResizeMode(COL_ACTIONS, QHeaderView.ResizeMode.Interactive)
        header.setSectionResizeMode(COL_ACT_RUN, QHeaderView.ResizeMode.Interactive)

        # Settings
        self.tree.setIndentation(20)
        self.tree.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.tree.setDragEnabled(True)
        self.tree.setAcceptDrops(True)
        self.tree.setDropIndicatorShown(True)
        self.tree.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)

        # Delegate
        self.delegate = SessionDelegate(self.tree)
        self.tree.setItemDelegate(self.delegate)

        # Signals
        self.tree.itemClicked.connect(self.on_click)
        self.tree.itemDoubleClicked.connect(self.on_dbl_click)
        self.tree.itemChanged.connect(self.on_change)

        # Connect drop signal to restore buttons
        self.tree.itemsDropped.connect(self.refresh_all_buttons)

        # Context Menu
        self.tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_context_menu)

        self.layout.addWidget(self.tree)

    def _mk_btn(self, text, color, slot):
        b = QPushButton(text)
        b.setFixedSize(90, 30)
        b.setStyleSheet(f"background-color: {color}; color: white; font-weight: bold; border-radius: 3px;")
        b.clicked.connect(slot)
        return b

    # --- AUTO SAVE ---
    def closeEvent(self, event):
        """Auto save on exit."""
        self.save_data(silent=True)
        self._save_settings()
        event.accept()

    def _save_settings(self):
        settings = {
            "geometry": self.saveGeometry().toBase64().data().decode(),
            "column_widths": [self.tree.columnWidth(i) for i in range(COL_COUNT)]
        }
        try:
            with open(SETTINGS_FILE, 'w') as f:
                json.dump(settings, f)
        except Exception as e:
            print(f"Failed to save settings: {e}")

    def _load_settings(self):
        if not os.path.exists(SETTINGS_FILE): return
        try:
            with open(SETTINGS_FILE, 'r') as f:
                settings = json.load(f)
                if "geometry" in settings:
                    self.restoreGeometry(QByteArray.fromBase64(settings["geometry"].encode()))
                if "column_widths" in settings:
                    for i, w in enumerate(settings["column_widths"]):
                        if i < COL_COUNT:
                            self.tree.setColumnWidth(i, w)
        except Exception as e:
            print(f"Failed to load settings: {e}")

    # --- DATA MANIPULATION ---

    def create_item_widget(self, parent_widget, data_dict=None):
        """Creates a tree item from data dictionary."""
        item = QTreeWidgetItem(parent_widget)
        item.setSizeHint(0, QSize(0, ROW_HEIGHT))
        item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)

        if not data_dict:
            data_dict = {}

        # Set ID
        uid = data_dict.get('id', str(uuid.uuid4()))
        item.setData(0, ROLE_ID, uid)

        # Set Colors (Stored in Col 0 now)
        c1 = data_dict.get('c1', '#ffffff')
        c2 = data_dict.get('c2', '#000000')
        item.setData(0, ROLE_C1, c1)
        item.setData(0, ROLE_C2, c2)

        # Set Icon
        icon_path = data_dict.get('icon', '')
        item.setData(COL_ICON, ROLE_ICON_PATH, icon_path)

        # Set Texts
        item.setText(COL_TITLE, data_dict.get('title', 'New Item'))
        item.setText(COL_TYPE, data_dict.get('type', ''))
        item.setText(COL_ENV, data_dict.get('env', ''))
        item.setText(COL_DEST, data_dict.get('dest', ''))
        item.setText(COL_PORT, data_dict.get('port', ''))
        item.setText(COL_LOGIN, data_dict.get('login', ''))
        item.setText(COL_PASSWORD, data_dict.get('password', ''))
        item.setText(COL_PATH, data_dict.get('path', ''))
        item.setText(COL_NOTE, data_dict.get('note', ''))

        self._setup_buttons(item)
        return item

    def _setup_buttons(self, item):
        """Adds action buttons to the row."""

        def mk_btn(icon_name, color, std_icon, slot, tooltip):
            b = QPushButton()
            b.setFixedSize(22, 22)
            b.setFlat(True)
            b.setToolTip(tooltip)
            b.setStyleSheet("border: none; margin: 0px;")
            if HAS_QTA:
                b.setIcon(qta.icon(icon_name, color=color))
            else:
                b.setIcon(self.style().standardIcon(std_icon))
            b.clicked.connect(lambda: slot(item))
            return b

        def mk_color_btn(item, role, tooltip):
            b = QPushButton()
            b.setFixedSize(22, 22)
            b.setFlat(True)
            b.setToolTip(tooltip)
            b.setStyleSheet("border: none; margin: 0px;")

            if HAS_QTA:
                # Use a specific icon (palette) for the button graphic
                # We do not tint it with the user color here, we keep it generic
                b.setIcon(qta.icon('fa5s.palette', color='#607d8b'))
            else:
                # Emoji fallback
                b.setText("ðŸŽ¨")
                b.setStyleSheet("border: none; margin: 0px; font-size: 14px; background-color: transparent;")

            # Logic to change color
            def pick():
                curr_col = item.data(0, role) or "#ffffff"
                c = QColorDialog.getColor(QColor(curr_col), self)
                if c.isValid():
                    item.setData(0, role, c.name())
                    # Trigger tree repaint to show row colors
                    self.tree.viewport().update()

            b.clicked.connect(pick)
            return b

        # --- ACTIONS COLUMN (Consolidated) ---
        actions_widget = QWidget()
        layout = QHBoxLayout(actions_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(2)

        # Add buttons
        layout.addWidget(mk_btn('fa5s.copy', '#2196f3', QStyle.StandardPixmap.SP_FileIcon, self.act_dup, "Duplicate"))
        layout.addWidget(mk_btn('fa5s.arrow-up', '#607d8b', QStyle.StandardPixmap.SP_ArrowUp, self.act_up, "Move Up"))
        layout.addWidget(
            mk_btn('fa5s.arrow-down', '#607d8b', QStyle.StandardPixmap.SP_ArrowDown, self.act_down, "Move Down"))
        layout.addWidget(
            mk_btn('fa5s.times', '#f44336', QStyle.StandardPixmap.SP_DialogCloseButton, self.act_del, "Delete"))

        # Add Color Buttons (Updated to transparent background)
        layout.addWidget(mk_color_btn(item, ROLE_C1, "Row Color (C1)"))
        layout.addWidget(mk_color_btn(item, ROLE_C2, "Text Color (C2)"))

        layout.addStretch()  # Push everything to left
        self.tree.setItemWidget(item, COL_ACTIONS, actions_widget)

        # --- RUN COLUMN (Centered) ---
        stype = item.text(COL_TYPE)
        if stype != "Group":
            run_container = QWidget()
            run_layout = QHBoxLayout(run_container)
            run_layout.setContentsMargins(0, 0, 0, 0)
            run_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)  # Center alignment

            btn = mk_btn('fa5s.play', '#4caf50', QStyle.StandardPixmap.SP_MediaPlay, self.act_run, "Run")
            run_layout.addWidget(btn)

            self.tree.setItemWidget(item, COL_ACT_RUN, run_container)

    def refresh_all_buttons(self):
        iterator = QTreeWidgetItemIterator(self.tree)
        while iterator.value():
            item = iterator.value()
            # If the Actions widget is missing, re-setup
            if not self.tree.itemWidget(item, COL_ACTIONS):
                self._setup_buttons(item)
            iterator += 1

    def add_item(self, is_group=False):
        sel_items = self.tree.selectedItems()
        parent = self.tree.invisibleRootItem()

        if sel_items:
            sel = sel_items[0]
            sel_type = sel.text(COL_TYPE)
            if sel_type == "Group":
                parent = sel
                parent.setExpanded(True)
            else:
                parent = sel.parent() or self.tree.invisibleRootItem()

        data = {
            'title': 'New Group' if is_group else 'New Session',
            'type': 'Group' if is_group else '',
            'env': '',
            'icon': ''
        }

        if is_group:
            data['type'] = 'Group'
            data['icon'] = f"std_{QStyle.StandardPixmap.SP_DirIcon.value}"

        item = self.create_item_widget(parent, data)
        self._update_icon_from_type(item)

    # --- ACTIONS ---
    def act_run(self, item):
        t = item.text(COL_TYPE)
        dest = item.text(COL_DEST)
        pwd = item.text(COL_PASSWORD)
        user = item.text(COL_LOGIN)

        if t == "SSH":
            cmd = [PUTTY_PATH, "-ssh", f"{user}@{dest}", "-pw", pwd]
            try:
                subprocess.Popen(cmd)
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to start PuTTY: {e}")
        elif t == "WEB":
            webbrowser.open(dest)
        elif t == "TELNET":
            os.system(f"start telnet {dest}")

    def act_dup(self, item):
        parent = item.parent() or self.tree.invisibleRootItem()
        data = self._item_to_dict(item)
        data['id'] = str(uuid.uuid4())
        data['title'] += " (Copy)"

        new_item = self.create_item_widget(parent, data)

    def act_del(self, item):
        res = QMessageBox.question(self, "Delete", f"Delete '{item.text(COL_TITLE)}'?",
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if res == QMessageBox.StandardButton.Yes:
            (item.parent() or self.tree.invisibleRootItem()).removeChild(item)

    def act_up(self, item):
        parent = item.parent() or self.tree.invisibleRootItem()
        idx = parent.indexOfChild(item)
        if idx > 0:
            parent.takeChild(idx)
            parent.insertChild(idx - 1, item)
            self._setup_buttons(item)
            self.tree.setCurrentItem(item)

    def act_down(self, item):
        parent = item.parent() or self.tree.invisibleRootItem()
        idx = parent.indexOfChild(item)
        if idx < parent.childCount() - 1:
            parent.takeChild(idx)
            parent.insertChild(idx + 1, item)
            self._setup_buttons(item)
            self.tree.setCurrentItem(item)

    # --- EVENTS ---
    def on_click(self, item, col):
        if col == COL_ICON:
            self._pick_icon(item)
        elif col == COL_PASSWORD:
            pwd = item.text(COL_PASSWORD)
            if pwd:
                QApplication.clipboard().setText(pwd)
            self.tree.editItem(item, col)

    def on_dbl_click(self, item, col):
        # NOTE: C1/C2 double click removed as they are now buttons in Actions col
        if col == COL_NOTE:
            dlg = NoteDialog(item.text(COL_NOTE), self)
            if dlg.exec():
                item.setText(COL_NOTE, dlg.get_text())
        elif col < COL_ACTIONS:
            self.tree.editItem(item, col)

    def on_change(self, item, col):
        if col == COL_TYPE:
            self._update_icon_from_type(item)
            self._setup_buttons(item)

    def _update_icon_from_type(self, item):
        t = item.text(COL_TYPE)
        icon_val = -1

        if t == "SSH":
            icon_val = QStyle.StandardPixmap.SP_ComputerIcon.value
        elif t == "TELNET":
            icon_val = QStyle.StandardPixmap.SP_MediaPlay.value
        elif t == "APP":
            icon_val = QStyle.StandardPixmap.SP_TitleBarMaxButton.value
        elif t == "WEB":
            icon_val = QStyle.StandardPixmap.SP_DriveNetIcon.value
        elif t == "PASSWORD":
            icon_val = QStyle.StandardPixmap.SP_MessageBoxInformation.value
        elif t == "Group":
            icon_val = QStyle.StandardPixmap.SP_DirIcon.value

        if icon_val != -1:
            item.setData(COL_ICON, ROLE_ICON_PATH, f"std_{icon_val}")

    def on_context_menu(self, pos):
        item = self.tree.itemAt(pos)
        if not item: return

        menu = QMenu()

        if item.text(COL_TYPE) != "Group":
            a_run = menu.addAction("Run")
            a_run.setIcon(get_icon('fa5s.play', '#4caf50', QStyle.StandardPixmap.SP_MediaPlay))
            a_run.triggered.connect(lambda: self.act_run(item))

        a_dup = menu.addAction("Duplicate")
        a_dup.setIcon(get_icon('fa5s.copy', '#2196f3', QStyle.StandardPixmap.SP_FileIcon))
        a_dup.triggered.connect(lambda: self.act_dup(item))

        a_del = menu.addAction("Delete")
        a_del.setIcon(get_icon('fa5s.times', '#f44336', QStyle.StandardPixmap.SP_DialogCloseButton))
        a_del.triggered.connect(lambda: self.act_del(item))

        menu.addSeparator()

        a_up = menu.addAction("Move Up")
        a_up.setIcon(get_icon('fa5s.arrow-up', '#607d8b', QStyle.StandardPixmap.SP_ArrowUp))
        a_up.triggered.connect(lambda: self.act_up(item))

        a_dn = menu.addAction("Move Down")
        a_dn.setIcon(get_icon('fa5s.arrow-down', '#607d8b', QStyle.StandardPixmap.SP_ArrowDown))
        a_dn.triggered.connect(lambda: self.act_down(item))

        menu.exec(self.tree.viewport().mapToGlobal(pos))

    # --- HELPERS ---
    def _pick_icon(self, item):
        dlg = IconPickerDialog(self)
        if dlg.exec():
            item.setData(COL_ICON, ROLE_ICON_PATH, dlg.result_icon)

    def _item_to_dict(self, item):
        return {
            'id': item.data(0, ROLE_ID),
            'title': item.text(COL_TITLE),
            'type': item.text(COL_TYPE),
            'env': item.text(COL_ENV),
            'dest': item.text(COL_DEST),
            'port': item.text(COL_PORT),
            'login': item.text(COL_LOGIN),
            'password': item.text(COL_PASSWORD),
            'path': item.text(COL_PATH),
            'note': item.text(COL_NOTE),
            'icon': item.data(COL_ICON, ROLE_ICON_PATH),
            'c1': item.data(0, ROLE_C1),  # From Col 0 now
            'c2': item.data(0, ROLE_C2),  # From Col 0 now
        }

    # --- SAVE / LOAD ---
    def save_data(self, silent=False):
        try:
            rows = []

            def traverse(parent_item, parent_id_str):
                count = parent_item.childCount() if parent_item else self.tree.topLevelItemCount()
                for i in range(count):
                    item = parent_item.child(i) if parent_item else self.tree.topLevelItem(i)
                    d = self._item_to_dict(item)
                    d['duuid'] = parent_id_str
                    rows.append(d)
                    traverse(item, d['id'])

            traverse(None, "")

            with open(DATA_FILE, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f,
                                        fieldnames=['id', 'duuid', 'title', 'type', 'env', 'dest', 'port', 'login',
                                                    'password', 'path', 'note', 'icon', 'c1', 'c2'])
                writer.writeheader()
                writer.writerows(rows)

            if not silent:
                QMessageBox.information(self, "Saved", f"Successfully saved to:\n{DATA_FILE}")

        except Exception as e:
            if not silent:
                QMessageBox.critical(self, "Error", str(e))
            else:
                print(f"Auto-save failed: {e}")

    def _load_data(self):
        self.tree.clear()
        if not os.path.exists(DATA_FILE): return

        self.tree.setUpdatesEnabled(False)  # Optimize load
        try:
            # Phase 1: Load all rows
            all_items = {}
            parent_map = {}

            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    p_id = row.get('duuid', '')
                    if 'parent_id' in row and not p_id: p_id = row['parent_id']

                    item = self.create_item_widget(None, row)
                    all_items[row['id']] = item
                    parent_map[row['id']] = p_id

            # Phase 2: Link parents
            for iid, item in all_items.items():
                pid = parent_map.get(iid)
                if pid and pid in all_items:
                    all_items[pid].addChild(item)
                else:
                    self.tree.addTopLevelItem(item)

                self._setup_buttons(item)

            self.tree.expandAll()
        except Exception as e:
            print(f"Load Error: {e}")
        finally:
            self.tree.setUpdatesEnabled(True)

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export", "", "CSV (*.csv)")
        if path:
            shutil.copy(DATA_FILE, path)
            QMessageBox.information(self, "Export", "Done.")

    def import_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Import", "", "CSV (*.csv)")
        if not path: return

        self.tree.setUpdatesEnabled(False)  # Optimize import
        try:
            with open(path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                rows = list(reader)

            old_to_new = {}
            for row in rows:
                old_id = row.get('id')
                new_id = str(uuid.uuid4())
                old_to_new[old_id] = new_id
                row['id'] = new_id

            created_items = {}

            for row in rows:
                item = self.create_item_widget(None, row)
                created_items[row['id']] = item

            root = self.tree.invisibleRootItem()

            for row in rows:
                item = created_items[row['id']]
                old_parent_id = row.get('duuid', '')
                if not old_parent_id and 'parent_id' in row:
                    old_parent_id = row['parent_id']

                if old_parent_id in old_to_new:
                    new_parent_id = old_to_new[old_parent_id]
                    parent_item = created_items.get(new_parent_id)
                    if parent_item:
                        parent_item.addChild(item)
                    else:
                        root.addChild(item)
                else:
                    root.addChild(item)

                self._setup_buttons(item)

            QMessageBox.information(self, "Import", "Imported items with structure preserved.")

        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))
        finally:
            self.tree.setUpdatesEnabled(True)


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = SessionKeeperApp()
    window.show()
    sys.exit(app.exec())
