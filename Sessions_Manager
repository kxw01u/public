import sys
import os
import csv
import uuid
import shutil
import subprocess
import webbrowser
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QTreeWidget, QTreeWidgetItem,
    QVBoxLayout, QHBoxLayout, QStyledItemDelegate, QLineEdit, QComboBox,
    QPushButton, QMessageBox, QColorDialog, QAbstractItemView, QStyle,
    QHeaderView, QStyleOptionViewItem, QFileDialog, QStyleOptionHeader,
    QDialog, QGridLayout, QLabel, QTabWidget, QDialogButtonBox, QMenu,
    QFrame, QTreeWidgetItemIterator
)
from PyQt6.QtGui import (
    QColor, QBrush, QPen, QIcon, QPixmap, QAction, QGuiApplication, QPainter, QFont, QPalette
)
from PyQt6.QtCore import (
    Qt, QSize, pyqtSignal, QRect, QMimeData, QByteArray, QPoint
)

# --- CONFIGURATION ---
DATA_FILE_NAME = "Sessions_keeper.csv"
DATA_FILE = os.path.join(os.getcwd(), DATA_FILE_NAME)
SETTINGS_FILE = "settings.json"
CUSTOM_ICON_DIR = "user_icons"
PUTTY_PATH = "C:\\Program Files\\PuTTY\\putty.exe"
ROW_HEIGHT = 32

# --- COLUMN DEFINITIONS ---
COL_ICON = 0
COL_TITLE = 1
COL_TYPE = 2
COL_ENV = 3
COL_DEST = 4
COL_PORT = 5
COL_LOGIN = 6
COL_PASSWORD = 7
COL_PATH = 8
# Actions
COL_ACT_RUN = 9
COL_ACT_DUP = 10
COL_ACT_DEL = 11
COL_ACT_UP = 12
COL_ACT_DOWN = 13
# Colors
COL_C1 = 14
COL_C2 = 15
COL_COUNT = 16

# Data Roles for storage
ROLE_ID = Qt.ItemDataRole.UserRole + 1
ROLE_C1 = Qt.ItemDataRole.UserRole + 2
ROLE_C2 = Qt.ItemDataRole.UserRole + 3
ROLE_ICON_PATH = Qt.ItemDataRole.UserRole + 4

# --- HELPER: CHECK ICONS ---
HAS_QTA = False
try:
    import qtawesome as qta

    HAS_QTA = True
except ImportError:
    pass


def get_icon(name, color, fallback_std):
    """Returns qtawesome icon if available, else standard PyQt icon."""
    if HAS_QTA:
        return qta.icon(name, color=color)
    else:
        return QApplication.style().standardIcon(fallback_std)


# --- CUSTOM HEADER ---
class MergedHeaderView(QHeaderView):
    def __init__(self, orientation, parent=None):
        super().__init__(orientation, parent)

    def paintSection(self, painter, rect, logicalIndex):
        # Action Block (Columns 9-13)
        if COL_ACT_RUN <= logicalIndex <= COL_ACT_DOWN:
            painter.save()
            opt = QStyleOptionHeader()
            self.initStyleOption(opt)
            opt.rect = rect
            opt.section = logicalIndex
            opt.text = ""
            self.style().drawControl(QStyle.ControlElement.CE_HeaderSection, opt, painter, self)

            # Draw "Actions" label centered over the Delete column (middle of block)
            if logicalIndex == COL_ACT_DEL:
                painter.setClipping(False)
                width_of_5_cols = 30 * 5
                span_rect = QRect(rect)
                span_rect.setLeft(rect.left() - (30 * 2))  # Shift back to cover Run/Dup
                span_rect.setWidth(width_of_5_cols)

                # REVISION 2: Remove the header "Actions"
                opt.text = ""
                opt.rect = span_rect
                self.style().drawControl(QStyle.ControlElement.CE_HeaderLabel, opt, painter, self)

            painter.restore()
        else:
            super().paintSection(painter, rect, logicalIndex)


# --- CUSTOM TREE WIDGET ---
class SessionTreeWidget(QTreeWidget):
    """Custom Tree Widget to handle clicks on empty space and drops."""

    # Signal emitted when an item is dropped
    itemsDropped = pyqtSignal()

    def mousePressEvent(self, event):
        # Check if the click is on an item
        item = self.itemAt(event.pos())
        if not item:
            # Clicked on empty space, clear selection
            self.clearSelection()

        # Pass the event to the parent class for standard handling
        super().mousePressEvent(event)

    def dropEvent(self, event):
        # Perform standard drop
        super().dropEvent(event)
        # REVISION 1: Emit signal to reload buttons
        self.itemsDropped.emit()


# --- DELEGATE (RENDERING & EDITING) ---
class SessionDelegate(QStyledItemDelegate):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.session_types = ["Group", "SSH", "TELNET", "PASSWORD", "WEB", "APP"]
        self.env_types = ["PROD", "UAT"]

    def initStyleOption(self, option, index):
        super().initStyleOption(option, index)
        # MASK PASSWORD IN DISPLAY MODE
        if index.column() == COL_PASSWORD:
            text = index.data(Qt.ItemDataRole.DisplayRole)
            if text:
                option.text = "â—" * 8  # Mask characters

    def createEditor(self, parent, option, index):
        col = index.column()
        # No editors for Icon, Actions, or Colors
        if col == COL_ICON or col >= COL_ACT_RUN:
            return None

        # Logic: If Group, only edit Title/Type/Env
        type_item = index.siblingAtColumn(COL_TYPE)
        type_text = type_item.data(Qt.ItemDataRole.DisplayRole)

        if type_text == "Group" and col not in (COL_TITLE, COL_TYPE, COL_ENV):
            return None

        if col == COL_TYPE:
            cb = QComboBox(parent)
            cb.addItems(self.session_types)
            return cb
        elif col == COL_ENV:
            cb = QComboBox(parent)
            cb.addItems(self.env_types)
            return cb
        elif col == COL_PASSWORD:
            le = QLineEdit(parent)
            le.setEchoMode(QLineEdit.EchoMode.Normal)  # Edit in plain text as requested
            return le

        return super().createEditor(parent, option, index)

    def setEditorData(self, editor, index):
        if isinstance(editor, QComboBox):
            text = index.data(Qt.ItemDataRole.DisplayRole)
            idx = editor.findText(text)
            if idx >= 0: editor.setCurrentIndex(idx)
        else:
            super().setEditorData(editor, index)

    def setModelData(self, editor, model, index):
        if isinstance(editor, QComboBox):
            model.setData(index, editor.currentText(), Qt.ItemDataRole.EditRole)
        else:
            super().setModelData(editor, model, index)

    def paint(self, painter, option, index):
        col = index.column()
        painter.save()

        # 1. Backgrounds
        # Utility columns (Icon, Actions, Colors) get flat white background
        is_utility = (col == COL_ICON or col >= COL_ACT_RUN)

        # Remove default focus/selection blue block for utilities
        opt = QStyleOptionViewItem(option)
        if is_utility:
            opt.state &= ~QStyle.StateFlag.State_Selected
            opt.state &= ~QStyle.StateFlag.State_HasFocus
            painter.fillRect(option.rect, Qt.GlobalColor.white)
        else:
            # For data columns, apply row colors if defined
            c1 = index.siblingAtColumn(COL_C1).data(ROLE_C1)
            if c1:
                painter.fillRect(option.rect, QColor(c1))

            # Draw Selection Border (instead of block)
            if option.state & QStyle.StateFlag.State_Selected:
                pen = QPen(option.palette.highlight().color(), 2)
                r = option.rect.adjusted(1, 1, -2, -2)
                painter.setPen(pen)
                painter.drawRect(r)

        # 2. Content
        if col in (COL_C1, COL_C2):
            # Draw Emoji ðŸŽ¨
            painter.setFont(QFont("Segoe UI Emoji", 10))
            painter.setPen(Qt.GlobalColor.black)
            painter.drawText(option.rect, Qt.AlignmentFlag.AlignCenter, "ðŸŽ¨")

        elif col == COL_ICON:
            icon_path = index.data(ROLE_ICON_PATH)
            icon = self._resolve_icon(icon_path)
            if icon:
                # Center icon
                size = 16
                x = option.rect.center().x() - size // 2
                y = option.rect.center().y() - size // 2
                painter.drawPixmap(x, y, icon.pixmap(size, size))

        elif col == COL_PASSWORD:
            # Draw masked text
            super().paint(painter, opt, index)

        elif col < COL_ACT_RUN:
            # Draw standard text
            # Ensure text color matches C2 setting
            c2 = index.siblingAtColumn(COL_C2).data(ROLE_C2)
            if c2:
                opt.palette.setColor(QPalette.ColorRole.Text, QColor(c2))

            # REVISION 3: Bold the group row
            type_val = index.siblingAtColumn(COL_TYPE).data(Qt.ItemDataRole.DisplayRole)
            if type_val == "Group":
                opt.font.setBold(True)

            super().paint(painter, opt, index)

        # 3. Grid Lines
        painter.setPen(QPen(QColor("#e0e0e0")))
        painter.drawLine(option.rect.bottomLeft(), option.rect.bottomRight())
        painter.drawLine(option.rect.topRight(), option.rect.bottomRight())

        painter.restore()

    def _resolve_icon(self, path):
        if not path: return None
        if path.startswith("std_"):
            try:
                val = int(path.split("_")[1])
                return QApplication.style().standardIcon(QStyle.StandardPixmap(val))
            except:
                return None
        elif path.startswith("custom|"):
            fname = path.split("|")[1]
            fpath = os.path.join(CUSTOM_ICON_DIR, fname)
            if os.path.exists(fpath):
                return QIcon(fpath)
        return None


# --- ICON PICKER DIALOG ---
class IconPickerDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Select Icon")
        self.setFixedSize(400, 300)
        self.result_icon = None

        if not os.path.exists(CUSTOM_ICON_DIR): os.makedirs(CUSTOM_ICON_DIR)

        layout = QVBoxLayout(self)
        tabs = QTabWidget()
        self.std_tab = QWidget()
        self.cust_tab = QWidget()

        tabs.addTab(self.std_tab, "Standard")
        tabs.addTab(self.cust_tab, "Custom")
        layout.addWidget(tabs)

        self._setup_std()
        self._setup_cust()

    def _setup_std(self):
        grid = QGridLayout(self.std_tab)
        icons = [
            QStyle.StandardPixmap.SP_DirIcon,
            QStyle.StandardPixmap.SP_ComputerIcon,
            QStyle.StandardPixmap.SP_DriveHDIcon,
            QStyle.StandardPixmap.SP_DriveNetIcon,
            QStyle.StandardPixmap.SP_FileIcon,
            QStyle.StandardPixmap.SP_DesktopIcon,
            QStyle.StandardPixmap.SP_TrashIcon,
            QStyle.StandardPixmap.SP_MediaPlay,
            QStyle.StandardPixmap.SP_MessageBoxWarning,
            QStyle.StandardPixmap.SP_MessageBoxQuestion
        ]
        for i, ic in enumerate(icons):
            btn = QPushButton()
            btn.setIcon(self.style().standardIcon(ic))
            btn.setFixedSize(32, 32)
            btn.clicked.connect(lambda _, x=f"std_{ic.value}": self._finish(x))
            grid.addWidget(btn, i // 5, i % 5)

    def _setup_cust(self):
        self.cust_layout = QGridLayout(self.cust_tab)
        self._refresh_cust()

    def _refresh_cust(self):
        # Clear
        while self.cust_layout.count():
            item = self.cust_layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()

        add_btn = QPushButton("+")
        add_btn.setFixedSize(32, 32)
        add_btn.clicked.connect(self._upload)
        self.cust_layout.addWidget(add_btn, 0, 0)

        files = [f for f in os.listdir(CUSTOM_ICON_DIR) if f.lower().endswith(('.png', '.ico', '.jpg'))]
        for i, f in enumerate(files[:19]):
            path = os.path.join(CUSTOM_ICON_DIR, f)
            btn = QPushButton()
            btn.setIcon(QIcon(path))
            btn.setFixedSize(32, 32)
            btn.clicked.connect(lambda _, x=f"custom|{f}": self._finish(x))
            r, c = (i + 1) // 5, (i + 1) % 5
            self.cust_layout.addWidget(btn, r, c)

    def _upload(self):
        path, _ = QFileDialog.getOpenFileName(self, "Image", "", "Images (*.png *.ico *.jpg)")
        if path:
            dest = os.path.join(CUSTOM_ICON_DIR, os.path.basename(path))
            shutil.copy(path, dest)
            self._refresh_cust()

    def _finish(self, val):
        self.result_icon = val
        self.accept()


# --- MAIN WINDOW ---
class SessionKeeperApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Session Keeper V3.0 (Revamped)")
        self.setGeometry(100, 100, 1400, 700)

        self.central = QWidget()
        self.setCentralWidget(self.central)
        self.layout = QVBoxLayout(self.central)

        self._init_ui()
        self._load_data()

    def _init_ui(self):
        # Toolbar
        tb = QHBoxLayout()

        b_grp = self._mk_btn("+ Group", "#ff9800", lambda: self.add_item(is_group=True))
        b_sess = self._mk_btn("+ Session", "#2196f3", lambda: self.add_item(is_group=False))
        b_imp = self._mk_btn("Import", "#9c27b0", self.import_csv)
        b_exp = self._mk_btn("Export", "#00bcd4", self.export_csv)
        b_save = self._mk_btn("Save", "#4caf50", self.save_data)

        tb.addWidget(b_grp)
        tb.addWidget(b_sess)
        tb.addSpacing(20)
        tb.addWidget(b_imp)
        tb.addWidget(b_exp)
        tb.addStretch()
        tb.addWidget(b_save)

        self.layout.addLayout(tb)

        # Tree - Using Custom Class
        self.tree = SessionTreeWidget()
        self.tree.setColumnCount(COL_COUNT)
        self.tree.setHeaderLabels(
            ["", "Title", "Type", "Env", "Destination", "Port", "Login", "Password", "Path", "", "", "", "", "", "C1",
             "C2"])

        # Header setup
        self.tree.setHeader(MergedHeaderView(Qt.Orientation.Horizontal, self.tree))
        header = self.tree.header()

        # Sizing
        self.tree.setColumnWidth(COL_ICON, 70)
        self.tree.setColumnWidth(COL_TITLE, 150)
        self.tree.setColumnWidth(COL_TYPE, 80)
        self.tree.setColumnWidth(COL_ENV, 70)
        self.tree.setColumnWidth(COL_DEST, 140)
        self.tree.setColumnWidth(COL_PORT, 60)
        self.tree.setColumnWidth(COL_C1, 40)
        self.tree.setColumnWidth(COL_C2, 40)

        # Fix Action Columns to 30px strict
        for c in range(COL_ACT_RUN, COL_ACT_DOWN + 1):
            self.tree.setColumnWidth(c, 30)
            header.setSectionResizeMode(c, QHeaderView.ResizeMode.Fixed)

        # Settings
        self.tree.setIndentation(20)
        self.tree.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        self.tree.setDragEnabled(True)
        self.tree.setAcceptDrops(True)
        self.tree.setDropIndicatorShown(True)
        self.tree.setDragDropMode(QAbstractItemView.DragDropMode.InternalMove)

        # Delegate
        self.delegate = SessionDelegate(self.tree)
        self.tree.setItemDelegate(self.delegate)

        # Signals
        self.tree.itemClicked.connect(self.on_click)
        self.tree.itemDoubleClicked.connect(self.on_dbl_click)
        self.tree.itemChanged.connect(self.on_change)

        # Connect drop signal to restore buttons
        self.tree.itemsDropped.connect(self.refresh_all_buttons)

        # Context Menu
        self.tree.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.tree.customContextMenuRequested.connect(self.on_context_menu)

        self.layout.addWidget(self.tree)

    def _mk_btn(self, text, color, slot):
        b = QPushButton(text)
        b.setFixedSize(90, 30)
        b.setStyleSheet(f"background-color: {color}; color: white; font-weight: bold; border-radius: 3px;")
        b.clicked.connect(slot)
        return b

    # --- DATA MANIPULATION ---

    def create_item_widget(self, parent_widget, data_dict=None):
        """Creates a tree item from data dictionary."""
        item = QTreeWidgetItem(parent_widget)
        item.setSizeHint(0, QSize(0, ROW_HEIGHT))
        item.setFlags(item.flags() | Qt.ItemFlag.ItemIsEditable)

        if not data_dict:
            data_dict = {}

        # Set ID
        uid = data_dict.get('id', str(uuid.uuid4()))
        item.setData(0, ROLE_ID, uid)

        # Set Colors
        c1 = data_dict.get('c1', '#ffffff')
        c2 = data_dict.get('c2', '#000000')
        item.setData(COL_C1, ROLE_C1, c1)
        item.setData(COL_C2, ROLE_C2, c2)

        # Set Icon
        icon_path = data_dict.get('icon', '')
        item.setData(COL_ICON, ROLE_ICON_PATH, icon_path)

        # Set Texts
        item.setText(COL_TITLE, data_dict.get('title', 'New Item'))
        item.setText(COL_TYPE, data_dict.get('type', 'SSH'))
        item.setText(COL_ENV, data_dict.get('env', 'PROD'))
        item.setText(COL_DEST, data_dict.get('dest', ''))
        item.setText(COL_PORT, data_dict.get('port', ''))
        item.setText(COL_LOGIN, data_dict.get('login', ''))
        item.setText(COL_PASSWORD, data_dict.get('password', ''))
        item.setText(COL_PATH, data_dict.get('path', ''))

        self._setup_buttons(item)
        return item

    def _setup_buttons(self, item):
        """Adds action buttons to the row."""

        def mk_act_btn(icon_name, color, std_icon, slot):
            b = QPushButton()
            b.setFixedSize(24, 24)
            b.setFlat(True)
            b.setStyleSheet("border: none;")
            if HAS_QTA:
                b.setIcon(qta.icon(icon_name, color=color))
            else:
                b.setIcon(self.style().standardIcon(std_icon))
            b.clicked.connect(lambda: slot(item))
            return b

        # Logic for Run button visibility
        stype = item.text(COL_TYPE)
        if stype != "Group":
            self.tree.setItemWidget(item, COL_ACT_RUN,
                                    mk_act_btn('fa5s.play', '#4caf50', QStyle.StandardPixmap.SP_MediaPlay,
                                               self.act_run))

        self.tree.setItemWidget(item, COL_ACT_DUP,
                                mk_act_btn('fa5s.copy', '#2196f3', QStyle.StandardPixmap.SP_FileIcon, self.act_dup))
        self.tree.setItemWidget(item, COL_ACT_DEL,
                                mk_act_btn('fa5s.times', '#f44336', QStyle.StandardPixmap.SP_DialogCloseButton,
                                           self.act_del))
        self.tree.setItemWidget(item, COL_ACT_UP,
                                mk_act_btn('fa5s.arrow-up', '#607d8b', QStyle.StandardPixmap.SP_ArrowUp, self.act_up))
        self.tree.setItemWidget(item, COL_ACT_DOWN,
                                mk_act_btn('fa5s.arrow-down', '#607d8b', QStyle.StandardPixmap.SP_ArrowDown,
                                           self.act_down))

    # REVISION 1: Method to restore buttons after drop
    def refresh_all_buttons(self):
        iterator = QTreeWidgetItemIterator(self.tree)
        while iterator.value():
            item = iterator.value()
            # If the Delete button is missing (checking one is enough), re-setup
            if not self.tree.itemWidget(item, COL_ACT_DEL):
                self._setup_buttons(item)
            iterator += 1

    def add_item(self, is_group=False):
        sel_items = self.tree.selectedItems()
        parent = self.tree.invisibleRootItem()

        # SMART PLACEMENT LOGIC
        if sel_items:
            sel = sel_items[0]
            sel_type = sel.text(COL_TYPE)
            if sel_type == "Group":
                # Add as Child
                parent = sel
                parent.setExpanded(True)
            else:
                # Add as Sibling
                parent = sel.parent() or self.tree.invisibleRootItem()

        default_icon = f"std_{QStyle.StandardPixmap.SP_DirIcon.value}" if is_group else ""

        data = {
            'title': 'New Group' if is_group else 'New Session',
            'type': 'Group' if is_group else 'SSH',
            'icon': default_icon
        }

        item = self.create_item_widget(parent, data)
        # IMPORTANT: Do not select the new item automatically to avoid staircase effect on rapid adds
        # self.tree.setCurrentItem(item)

    # --- ACTIONS ---
    def act_run(self, item):
        t = item.text(COL_TYPE)
        dest = item.text(COL_DEST)
        pwd = item.text(COL_PASSWORD)
        user = item.text(COL_LOGIN)

        if t == "SSH":
            cmd = [PUTTY_PATH, "-ssh", f"{user}@{dest}", "-pw", pwd]
            try:
                subprocess.Popen(cmd)
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Failed to start PuTTY: {e}")
        elif t == "WEB":
            webbrowser.open(dest)
        elif t == "TELNET":
            os.system(f"start telnet {dest}")

    def act_dup(self, item):
        parent = item.parent() or self.tree.invisibleRootItem()
        data = self._item_to_dict(item)
        data['id'] = str(uuid.uuid4())  # New ID
        data['title'] += " (Copy)"

        new_item = self.create_item_widget(parent, data)

    def act_del(self, item):
        res = QMessageBox.question(self, "Delete", f"Delete '{item.text(COL_TITLE)}'?",
                                   QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
        if res == QMessageBox.StandardButton.Yes:
            (item.parent() or self.tree.invisibleRootItem()).removeChild(item)

    def act_up(self, item):
        parent = item.parent() or self.tree.invisibleRootItem()
        idx = parent.indexOfChild(item)
        if idx > 0:
            parent.takeChild(idx)
            parent.insertChild(idx - 1, item)
            self._setup_buttons(item)  # Re-bind buttons
            self.tree.setCurrentItem(item)

    def act_down(self, item):
        parent = item.parent() or self.tree.invisibleRootItem()
        idx = parent.indexOfChild(item)
        if idx < parent.childCount() - 1:
            parent.takeChild(idx)
            parent.insertChild(idx + 1, item)
            self._setup_buttons(item)
            self.tree.setCurrentItem(item)

    # --- EVENTS ---
    def on_click(self, item, col):
        if col == COL_ICON:
            self._pick_icon(item)
        elif col == COL_PASSWORD:
            # REVISION 4: Copy password to clipboard and start editing on single click
            pwd = item.text(COL_PASSWORD)
            if pwd:
                QApplication.clipboard().setText(pwd)
            self.tree.editItem(item, col)
        # Clicking outside edit zones or buttons just selects row (default)

    def on_dbl_click(self, item, col):
        if col == COL_C1:
            self._pick_color(item, ROLE_C1, COL_C1)
        elif col == COL_C2:
            self._pick_color(item, ROLE_C2, COL_C2)
        elif col < COL_ACT_RUN:
            self.tree.editItem(item, col)

    def on_change(self, item, col):
        # If Type changed to/from Group, might need to update buttons (e.g. Run btn)
        if col == COL_TYPE:
            self._setup_buttons(item)

    def on_context_menu(self, pos):
        item = self.tree.itemAt(pos)
        if not item: return

        menu = QMenu()

        # Run
        if item.text(COL_TYPE) != "Group":
            a_run = menu.addAction("Run")
            a_run.setIcon(get_icon('fa5s.play', '#4caf50', QStyle.StandardPixmap.SP_MediaPlay))
            a_run.triggered.connect(lambda: self.act_run(item))

        a_dup = menu.addAction("Duplicate")
        a_dup.setIcon(get_icon('fa5s.copy', '#2196f3', QStyle.StandardPixmap.SP_FileIcon))
        a_dup.triggered.connect(lambda: self.act_dup(item))

        a_del = menu.addAction("Delete")
        a_del.setIcon(get_icon('fa5s.times', '#f44336', QStyle.StandardPixmap.SP_DialogCloseButton))
        a_del.triggered.connect(lambda: self.act_del(item))

        menu.addSeparator()

        a_up = menu.addAction("Move Up")
        a_up.setIcon(get_icon('fa5s.arrow-up', '#607d8b', QStyle.StandardPixmap.SP_ArrowUp))
        a_up.triggered.connect(lambda: self.act_up(item))

        a_dn = menu.addAction("Move Down")
        a_dn.setIcon(get_icon('fa5s.arrow-down', '#607d8b', QStyle.StandardPixmap.SP_ArrowDown))
        a_dn.triggered.connect(lambda: self.act_down(item))

        menu.exec(self.tree.viewport().mapToGlobal(pos))

    # --- HELPERS ---
    def _pick_icon(self, item):
        dlg = IconPickerDialog(self)
        if dlg.exec():
            item.setData(COL_ICON, ROLE_ICON_PATH, dlg.result_icon)

    def _pick_color(self, item, role, col):
        # CORRECTED: Must pass column index to data()
        curr = item.data(col, role) or "#ffffff"
        c = QColorDialog.getColor(QColor(curr), self)
        if c.isValid():
            item.setData(col, role, c.name())

    def _item_to_dict(self, item):
        return {
            'id': item.data(0, ROLE_ID),
            'title': item.text(COL_TITLE),
            'type': item.text(COL_TYPE),
            'env': item.text(COL_ENV),
            'dest': item.text(COL_DEST),
            'port': item.text(COL_PORT),
            'login': item.text(COL_LOGIN),
            'password': item.text(COL_PASSWORD),
            'path': item.text(COL_PATH),
            'icon': item.data(COL_ICON, ROLE_ICON_PATH),
            'c1': item.data(COL_C1, ROLE_C1),
            'c2': item.data(COL_C2, ROLE_C2),
        }

    # --- SAVE / LOAD ---
    def save_data(self):
        try:
            # We traverse the tree to get the exact state
            rows = []

            def traverse(parent_item, parent_id_str):
                count = parent_item.childCount() if parent_item else self.tree.topLevelItemCount()
                for i in range(count):
                    item = parent_item.child(i) if parent_item else self.tree.topLevelItem(i)
                    d = self._item_to_dict(item)
                    d['parent_id'] = parent_id_str
                    rows.append(d)
                    traverse(item, d['id'])

            traverse(None, "")

            with open(DATA_FILE, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f,
                                        fieldnames=['id', 'parent_id', 'title', 'type', 'env', 'dest', 'port', 'login',
                                                    'password', 'path', 'icon', 'c1', 'c2'])
                writer.writeheader()
                writer.writerows(rows)

            QMessageBox.information(self, "Saved", f"Successfully saved to:\n{DATA_FILE}")

        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))

    def _load_data(self):
        self.tree.clear()
        if not os.path.exists(DATA_FILE): return

        try:
            # Phase 1: Load all rows
            all_items = {}
            parent_map = {}  # item_id -> parent_id

            with open(DATA_FILE, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    # Create widget immediately
                    item = self.create_item_widget(None, row)
                    all_items[row['id']] = item
                    parent_map[row['id']] = row['parent_id']

            # Phase 2: Link parents
            for iid, item in all_items.items():
                pid = parent_map.get(iid)
                if pid and pid in all_items:
                    all_items[pid].addChild(item)
                else:
                    self.tree.addTopLevelItem(item)

                # Re-apply button widgets after adding to tree
                self._setup_buttons(item)

            self.tree.expandAll()

        except Exception as e:
            print(f"Load Error: {e}")

    def export_csv(self):
        path, _ = QFileDialog.getSaveFileName(self, "Export", "", "CSV (*.csv)")
        if path:
            shutil.copy(DATA_FILE, path)
            QMessageBox.information(self, "Export", "Done.")

    def import_csv(self):
        path, _ = QFileDialog.getOpenFileName(self, "Import", "", "CSV (*.csv)")
        if not path: return

        try:
            with open(path, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    # Gen new ID to avoid collision
                    row['id'] = str(uuid.uuid4())
                    item = self.create_item_widget(self.tree.invisibleRootItem(), row)
            QMessageBox.information(self, "Import", "Imported items to root level.")
        except Exception as e:
            QMessageBox.critical(self, "Error", str(e))


if __name__ == '__main__':
    app = QApplication(sys.argv)
    window = SessionKeeperApp()
    window.show()
    sys.exit(app.exec())
