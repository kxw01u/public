import sys
import re
import csv
import uuid
import os
import traceback
from datetime import timedelta, date
from PyQt6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, 
                             QHBoxLayout, QLabel, QPushButton, QFrame, QScrollArea, 
                             QLineEdit, QColorDialog, QSizePolicy, 
                             QStackedWidget, QDateEdit, QTreeWidget, QTreeWidgetItem, 
                             QAbstractItemView, QSplitter, QMenu, QAbstractSpinBox,
                             QCalendarWidget, QWidgetAction, QMessageBox,
                             QTreeWidgetItemIterator)
from PyQt6.QtCore import Qt, QDate, pyqtSignal, QTimer, QSize, QEvent, QSettings
from PyQt6.QtGui import QColor, QMouseEvent, QAction, QIcon, QPixmap

print("Starting Kanban Board v50 (Attribute Fix)...")

# --- 0. Global Synchronizer ---
class SplitterSynchronizer:
    def __init__(self):
        self.splitters = []
        self.is_syncing = False

    def add_splitter(self, splitter):
        self.splitters.append(splitter)
        splitter.splitterMoved.connect(lambda pos, idx: self.sync(splitter, pos, idx))
        if len(self.splitters) > 1:
            try: splitter.setSizes(self.splitters[0].sizes())
            except: pass

    def remove_splitter(self, splitter):
        if splitter in self.splitters:
            self.splitters.remove(splitter)

    def sync(self, sender, pos, index):
        if self.is_syncing: return
        self.is_syncing = True
        self.splitters = [s for s in self.splitters if not self._is_deleted(s)]
        try:
            sizes = sender.sizes()
            for s in self.splitters:
                if s != sender:
                    try: s.setSizes(sizes)
                    except: pass
        except: pass
        self.is_syncing = False
    
    def force_update(self):
        if not self.splitters: return
        self.is_syncing = True
        self.splitters = [s for s in self.splitters if not self._is_deleted(s)]
        try:
            base_sizes = self.splitters[0].sizes()
            for s in self.splitters[1:]:
                try: s.setSizes(base_sizes)
                except: pass
        except: pass
        self.is_syncing = False

    def _is_deleted(self, obj):
        try: 
            obj.sizes()
            return False
        except: return True

GLOBAL_SYNC = SplitterSynchronizer()

# --- 1. Helpers ---
def calculate_end_date(start_str, duration_str):
    try:
        y, m, d = map(int, str(start_str).split('-'))
        start_date = date(y, m, d)
    except:
        start_date = date.today()

    days = 0
    match = re.match(r"(\d+)\s*([dwm]?)", str(duration_str).lower())
    if match:
        amount = int(match.group(1))
        unit = match.group(2)
        if unit == 'w': days = amount * 5
        elif unit == 'm': days = amount * 22
        else: days = amount

    current_date = start_date
    added = 0
    while added < days:
        current_date += timedelta(days=1)
        if current_date.weekday() < 5: 
            added += 1
    return current_date.strftime("%Y-%m-%d")

def get_icon_for_date(end_date_str):
    if end_date_str == "?": return ""
    try:
        y, m, d = map(int, str(end_date_str).split('-'))
        end_date = date(y, m, d)
        today = date.today()
        if today > end_date: return "üî¥"
        if today == end_date: return "‚ùó"
        if today < end_date <= (today + timedelta(days=7)): return "‚ö°"
    except: pass
    return ""

def get_prio_color(p_text):
    p = str(p_text)[0]
    if p == "1": return "#D32F2F" # Red
    if p == "2": return "#9C27B0" # Purple
    if p == "3": return "#1976D2" # Blue
    if p == "4": return "#388E3C" # Green
    return "#757575"

# --- 2. Widgets ---

class PriorityButton(QPushButton):
    priorityChanged = pyqtSignal(str)
    def __init__(self, current_prio="3"):
        super().__init__()
        self.setFixedSize(24, 24)
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.current_prio = current_prio
        self.update_style(current_prio)
        self.clicked.connect(self.show_menu)

    def update_style(self, prio_text):
        self.current_prio = prio_text
        display = str(prio_text)[0]
        color = get_prio_color(prio_text)
        self.setText(display)
        self.setStyleSheet(f"background-color: {color}; color: white; border-radius: 4px; font-weight: bold; border: none;")

    def show_menu(self):
        menu = QMenu(self)
        actions = [("1", "#D32F2F"), ("2", "#9C27B0"), ("3", "#1976D2"), ("4", "#388E3C")]
        for label, color in actions:
            pix = QPixmap(16, 16)
            pix.fill(QColor(color))
            action = QAction(QIcon(pix), label, self)
            action.triggered.connect(lambda ch, val=label: self.handle_sel(val))
            menu.addAction(action)
        menu.exec(self.mapToGlobal(self.rect().bottomLeft()))

    def handle_sel(self, val):
        self.update_style(val)
        self.priorityChanged.emit(val)

class DateInputWidget(QWidget):
    editingFinished = pyqtSignal()
    def __init__(self):
        super().__init__()
        l = QHBoxLayout()
        l.setContentsMargins(0,0,0,0)
        l.setSpacing(2)
        self.setLayout(l)
        self.line = QLineEdit()
        self.line.setPlaceholderText("YYYY-MM-DD")
        self.line.setFixedWidth(85)
        self.line.editingFinished.connect(self.editingFinished.emit)
        self.btn = QPushButton("üìÖ")
        self.btn.setFixedSize(24, 24)
        self.btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.btn.setStyleSheet("border: none; background: transparent;")
        self.btn.clicked.connect(self.popup)
        l.addWidget(self.line)
        l.addWidget(self.btn)

    def setDate(self, d_str):
        self.line.setText(str(d_str))

    def popup(self):
        menu = QMenu(self)
        cal = QCalendarWidget()
        cal.setGridVisible(True)
        try:
            d = QDate.fromString(self.line.text(), "yyyy-MM-dd")
            if d.isValid(): cal.setSelectedDate(d)
            else: cal.setSelectedDate(QDate.currentDate())
        except: pass
        
        cal.activated.connect(lambda: self.sel(cal, menu))
        cal.clicked.connect(lambda: self.sel(cal, menu))
        ac = QWidgetAction(menu)
        ac.setDefaultWidget(cal)
        menu.addAction(ac)
        menu.exec(self.btn.mapToGlobal(self.btn.rect().bottomLeft()))

    def sel(self, cal, menu):
        self.line.setText(cal.selectedDate().toString("yyyy-MM-dd"))
        menu.close()
        self.editingFinished.emit()

class TaskCardWidget(QWidget):
    dataChanged = pyqtSignal(dict)
    sizeChanged = pyqtSignal()
    requestSave = pyqtSignal()
    requestDelete = pyqtSignal()

    def __init__(self, data, is_completed_row=False):
        super().__init__()
        self.data = data
        self.is_completed_row = is_completed_row
        if 'id' not in self.data: self.data['id'] = str(uuid.uuid4())

        layout = QVBoxLayout()
        layout.setContentsMargins(0,0,0,0)
        self.setLayout(layout)
        
        self.container = QFrame()
        self.container.setObjectName("CardContainer")
        layout.addWidget(self.container)

        self.stack = QStackedWidget()
        self.container.setLayout(QVBoxLayout())
        self.container.layout().setContentsMargins(6,6,6,6)
        self.container.layout().addWidget(self.stack)

        # View Mode
        self.view_widget = QWidget()
        hbox = QHBoxLayout(self.view_widget)
        hbox.setContentsMargins(0,0,0,0)
        self.lbl_prio = QLabel()
        self.lbl_prio.setFixedSize(20,20)
        self.lbl_prio.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lbl_name = QLabel()
        self.lbl_name.setStyleSheet("font-weight: bold;")
        self.lbl_info = QLabel()
        self.btn_del = QPushButton("√ó")
        self.btn_del.setFixedSize(16,16)
        self.btn_del.setCursor(Qt.CursorShape.PointingHandCursor)
        self.btn_del.clicked.connect(self.requestDelete.emit)
        self.btn_del.setStyleSheet("border:none; color:#999; font-weight:bold;")
        
        hbox.addWidget(self.lbl_prio)
        hbox.addWidget(self.lbl_name, 1)
        hbox.addWidget(self.lbl_info)
        hbox.addWidget(self.btn_del)

        # Edit Mode (FIX: USE self.edit_widget so save() can find it)
        self.edit_widget = QWidget()
        ebox = QHBoxLayout(self.edit_widget)
        ebox.setContentsMargins(0,0,0,0)
        
        self.in_prio = PriorityButton(data.get('priority', '3'))
        self.in_prio.priorityChanged.connect(lambda: self.save())
        
        self.in_name = QLineEdit()
        self.in_name.setPlaceholderText("Subject")
        self.in_name.editingFinished.connect(lambda: self.save())
        self.in_name.returnPressed.connect(lambda: self.save(True))

        self.in_pic = QLineEdit()
        self.in_pic.setPlaceholderText("PIC")
        self.in_pic.setFixedWidth(50)
        self.in_pic.editingFinished.connect(lambda: self.save())
        self.in_pic.returnPressed.connect(lambda: self.save(True))

        self.in_date = DateInputWidget()
        self.in_date.setFixedWidth(120)
        self.in_date.editingFinished.connect(lambda: self.save())

        self.in_dur = QLineEdit()
        self.in_dur.setPlaceholderText("2d")
        self.in_dur.setFixedWidth(40)
        self.in_dur.editingFinished.connect(lambda: self.save())
        self.in_dur.returnPressed.connect(lambda: self.save(True))

        ebox.addWidget(self.in_prio)
        ebox.addWidget(self.in_name)
        ebox.addWidget(self.in_pic)
        ebox.addWidget(self.in_date)
        ebox.addWidget(self.in_dur)

        self.stack.addWidget(self.view_widget)
        self.stack.addWidget(self.edit_widget)

        self.refresh_ui()

    def refresh_ui(self):
        # Data
        p = self.data.get('priority', '3')
        self.lbl_prio.setText(str(p)[0])
        self.lbl_prio.setStyleSheet(f"background-color: {get_prio_color(p)}; color: white; border-radius: 4px;")
        self.lbl_name.setText(self.data.get('name', ''))
        
        info = []
        if self.data.get('pic'): info.append(f"[{self.data['pic']}]")
        info.append(f"S: {self.data.get('start','')}")
        if self.data.get('duration'): info.append(f"({self.data['duration']})")
        info.append(f"E: {self.data.get('end','')} {self.get_date_icon()}")
        self.lbl_info.setText(" | ".join(info))

        # Inputs
        self.in_name.setText(self.data.get('name', ''))
        self.in_pic.setText(self.data.get('pic', ''))
        self.in_dur.setText(self.data.get('duration', ''))
        self.in_date.setDate(self.data.get('start', ''))
        self.in_prio.update_style(p)

        # Style
        stage = str(self.data.get('stage', '1'))
        is_gray = (stage == '3') or self.is_completed_row
        
        bg = "#E0E0E0" if is_gray else "white"
        txt = "#555" if is_gray else "#000"
        
        self.setStyleSheet(f"""
            QWidget#CardContainer {{ background: {bg}; border: 1px solid #ccc; border-radius: 6px; }}
            QLineEdit {{ background: transparent; border: none; border-bottom: 1px solid #aaa; color: {txt}; }}
            QLabel {{ color: {txt}; background: transparent; }}
        """)

    def get_date_icon(self):
        try:
            ed = self.data.get('end', '')
            if not ed or ed == "?": return ""
            y,m,d = map(int, ed.split('-'))
            dd = date(y,m,d)
            if date.today() > dd: return "üî¥"
            if date.today() == dd: return "‚ùó"
            if date.today() < dd <= date.today() + timedelta(days=7): return "‚ö°"
        except: pass
        return ""

    def start_edit(self):
        self.refresh_ui()
        self.stack.setCurrentIndex(1)
        self.in_name.setFocus()
        self.sizeChanged.emit()

    def save(self, close=False):
        self.data['name'] = self.in_name.text()
        self.data['pic'] = self.in_pic.text()
        self.data['duration'] = self.in_dur.text()
        self.data['priority'] = self.in_prio.current_prio
        self.data['start'] = self.in_date.line.text()
        self.data['end'] = calculate_end_date(self.data['start'], self.data['duration'])
        
        self.refresh_ui()
        self.dataChanged.emit(self.data)
        self.requestSave.emit()
        
        if close or not self.edit_widget.isAncestorOf(QApplication.focusWidget()):
            self.stack.setCurrentIndex(0)
            self.sizeChanged.emit()

# --- 2. Tree Column ---

class KanbanTree(QTreeWidget):
    contentChanged = pyqtSignal()
    heightChanged = pyqtSignal(int)
    itemCountChanged = pyqtSignal()

    def __init__(self, bg_color, stage_code, is_completed_project=False):
        super().__init__()
        self.stage_code = stage_code 
        self.is_completed_project = is_completed_project
        self.visual_height = 60
        
        self.setHeaderHidden(True)
        self.setIndentation(20)
        self.setAcceptDrops(True)
        self.setDragEnabled(True)
        self.setDragDropMode(QAbstractItemView.DragDropMode.DragDrop)
        self.setDefaultDropAction(Qt.DropAction.MoveAction)
        self.setSelectionMode(QAbstractItemView.SelectionMode.SingleSelection)
        
        self.setStyleSheet(f"QTreeWidget {{ background: {bg_color}; border: none; border-radius: 4px; }} QTreeWidget::item {{ background: transparent; margin: 1px; }}")
        
        self.itemDoubleClicked.connect(lambda item: self.itemWidget(item, 0).start_edit() if self.itemWidget(item,0) else None)
        self.itemExpanded.connect(self.update_height)
        self.itemCollapsed.connect(self.update_height)
        QTimer.singleShot(10, self.update_height)

    def mousePressEvent(self, event):
        if not self.itemAt(event.position().toPoint()):
            data = {
                'id': str(uuid.uuid4()), 'name': '', 'pic': '', 'priority': '3',
                'start': date.today().strftime("%Y-%m-%d"), 'duration': '', 'end': '?',
                'stage': str(self.stage_code)
            }
            self.add_item(data, is_new=True)
        else:
            super().mousePressEvent(event)

    def add_item(self, data, parent=None, is_new=False):
        item = QTreeWidgetItem()
        item.setData(0, Qt.ItemDataRole.UserRole, data)
        if parent: parent.addChild(item)
        else: self.addTopLevelItem(item)
        
        self.create_widget(item, data, is_new)
        self.update_height()
        self.itemCountChanged.emit()
        self.contentChanged.emit()
        return item

    def create_widget(self, item, data, is_new):
        item.setSizeHint(0, QSize(200, 44))
        w = TaskCardWidget(data, self.is_completed_project)
        w.dataChanged.connect(lambda d: self.update_data(item, d))
        w.requestSave.connect(self.contentChanged.emit)
        w.requestDelete.connect(lambda: self.delete_item(item))
        w.sizeChanged.connect(self.update_height)
        self.setItemWidget(item, 0, w)
        if is_new: w.start_edit()

    def update_data(self, item, data):
        item.setData(0, Qt.ItemDataRole.UserRole, data)
        if item.parent(): self.update_parent_dates(item.parent())
        self.contentChanged.emit()

    def delete_item(self, item):
        p = item.parent()
        if p: 
            p.removeChild(item)
            self.update_parent_dates(p)
        else: 
            self.takeTopLevelItem(self.indexOfTopLevelItem(item))
        self.update_height()
        self.itemCountChanged.emit()
        self.contentChanged.emit()

    def update_parent_dates(self, parent):
        if not parent: return
        p_data = parent.data(0, Qt.ItemDataRole.UserRole)
        count = parent.childCount()
        if count == 0: return

        starts = []
        ends = []
        for i in range(count):
            child = parent.child(i)
            cd = child.data(0, Qt.ItemDataRole.UserRole)
            try: starts.append(date.fromisoformat(cd.get('start')))
            except: pass
            try: ends.append(date.fromisoformat(cd.get('end')))
            except: pass
        
        changed = False
        if starts:
            mn = min(starts).strftime("%Y-%m-%d")
            if p_data.get('start') != mn: 
                p_data['start'] = mn
                changed = True
        if ends:
            mx = max(ends).strftime("%Y-%m-%d")
            if p_data.get('end') != mx:
                p_data['end'] = mx
                changed = True
        
        if changed:
            parent.setData(0, Qt.ItemDataRole.UserRole, p_data)
            w = self.itemWidget(parent, 0)
            if w: 
                w.data = p_data
                w.refresh_ui()
            self.contentChanged.emit()
        
        if parent.parent(): self.update_parent_dates(parent.parent())

    def update_height(self):
        h = 10
        def traverse(p):
            nonlocal h
            c = p.childCount() if p else self.topLevelItemCount()
            for i in range(c):
                it = p.child(i) if p else self.topLevelItem(i)
                h += 46 # approx card height
                if it.isExpanded(): traverse(it)
        traverse(None)
        if h < 60: h = 60
        self.visual_height = h
        self.heightChanged.emit(h)

    def dropEvent(self, event):
        event.setDropAction(Qt.DropAction.MoveAction)
        super().dropEvent(event)
        QTimer.singleShot(10, self.post_drop_logic)

    def post_drop_logic(self):
        self.rebuild_widgets_recursive(self.invisibleRootItem())
        self.update_height()
        self.itemCountChanged.emit()
        self.contentChanged.emit()

    def rebuild_widgets_recursive(self, parent):
        count = parent.childCount()
        for i in range(count):
            item = parent.child(i)
            data = item.data(0, Qt.ItemDataRole.UserRole)
            
            # Update Stage
            if data and str(data.get('stage')) != str(self.stage_code):
                data['stage'] = str(self.stage_code)
                item.setData(0, Qt.ItemDataRole.UserRole, data)
            
            if self.itemWidget(item, 0) is None and data:
                self.create_widget(item, data, is_new=False)
                item.setExpanded(True)

            w = self.itemWidget(item, 0)
            if w:
                w.is_completed_row = self.is_completed_project
                w.refresh_ui()

            self.rebuild_widgets_recursive(item)
            if item.parent(): self.update_parent_dates(item.parent())

# --- 3. Project Row ---

class ProjectRow(QFrame):
    requestSave = pyqtSignal()
    requestDelete = pyqtSignal(QFrame)

    def __init__(self, name, is_completed=False):
        super().__init__()
        self.is_completed = is_completed
        self.setObjectName("RowFrame")
        
        layout = QHBoxLayout(self)
        layout.setContentsMargins(5,5,5,5)
        
        # Header Box
        self.header_box = QFrame()
        self.header_box.setObjectName("ProjectBox")
        self.header_box.setFixedWidth(200)
        hlayout = QHBoxLayout(self.header_box)
        hlayout.setContentsMargins(5,5,5,5)
        
        # Controls
        ctrl = QVBoxLayout()
        self.btn_color = QPushButton()
        self.btn_color.setFixedSize(16,16)
        self.btn_color.setStyleSheet("border-radius:8px; border:none;")
        if not is_completed: self.btn_color.clicked.connect(self.pick_color)
        
        self.btn_font = QPushButton()
        self.btn_font.setFixedSize(16,16)
        if not is_completed: 
            self.btn_font.clicked.connect(self.toggle_font)
            self.btn_font.setCursor(Qt.CursorShape.PointingHandCursor)

        ctrl.addWidget(self.btn_color)
        ctrl.addWidget(self.btn_font)
        ctrl.addStretch()
        
        # Info
        info = QVBoxLayout()
        self.inp_name = QLineEdit(name)
        self.inp_name.setStyleSheet("background:transparent; border:none; font-weight:bold; font-size:14px;")
        self.inp_name.editingFinished.connect(self.requestSave.emit)
        if is_completed: self.inp_name.setReadOnly(True)

        btm = QHBoxLayout()
        self.lbl_stat = QLabel("(T:0|W:0|D:0)")
        self.lbl_stat.setStyleSheet("font-size:10px;")
        btm.addWidget(self.lbl_stat)
        btm.addStretch()
        
        if not is_completed:
            btn_x = QPushButton("√ó")
            btn_x.setFixedSize(20,20)
            btn_x.setStyleSheet("border:none; font-weight:bold; color:#555;")
            btn_x.clicked.connect(self.delete_self)
            btm.addWidget(btn_x)

        info.addWidget(self.inp_name)
        info.addStretch()
        info.addLayout(btm)

        hlayout.addLayout(ctrl)
        hlayout.addLayout(info)
        layout.addWidget(self.header_box)

        # Trees
        self.cols = []
        configs = [("#E3F2FD", 1), ("#FFF8E1", 2), ("#E8F5E9", 3)]
        
        self.splitter = QSplitter(Qt.Orientation.Horizontal)
        GLOBAL_SYNC.add_splitter(self.splitter)

        for bg, stage in configs:
            c_bg = "#F5F5F5" if is_completed else bg
            tree = KanbanTree(c_bg, stage, is_completed)
            tree.heightChanged.connect(lambda h: self.sync_row_height())
            tree.itemCountChanged.connect(self.update_stats)
            tree.contentChanged.connect(self.requestSave.emit)
            self.splitter.addWidget(tree)
            self.cols.append(tree)
        
        layout.addWidget(self.splitter)
        
        if is_completed:
            self.apply_theme("#E0E0E0") 
        else:
            self.apply_theme("#FFAB91")

    def sync_row_height(self):
        max_h = 60
        for c in self.cols:
            if c.visual_height > max_h:
                max_h = c.visual_height
        self.setFixedHeight(max_h + 10)

    def update_stats(self):
        cnts = []
        for c in self.cols:
            k = 0
            it = QTreeWidgetItemIterator(c)
            while it.value():
                k+=1
                it += 1
            cnts.append(str(k))
        self.lbl_stat.setText(f"(T:{cnts[0]}|W:{cnts[1]}|D:{cnts[2]})")

    def delete_self(self):
        if QMessageBox.question(self, "Delete", "Delete Project?") == QMessageBox.StandardButton.Yes:
            GLOBAL_SYNC.remove_splitter(self.splitter)
            self.requestDelete.emit(self)

    def pick_color(self):
        c = QColorDialog.getColor()
        if c.isValid(): 
            self.apply_theme(c.name())
            self.requestSave.emit()

    def toggle_font(self):
        ss = self.inp_name.styleSheet()
        new_c = "black" if "white" in ss else "white"
        self.inp_name.setStyleSheet(f"background:transparent; border:none; font-weight:bold; font-size:14px; color:{new_c};")
        self.lbl_stat.setStyleSheet(f"font-size:10px; color:{new_c};")
        self.update_font_btn(new_c)

    def update_font_btn(self, color_name):
        bg = "black" if color_name == "white" else "white"
        self.btn_font.setStyleSheet(f"background-color: {bg}; border-radius: 8px; border: 1px solid #777;")

    def apply_theme(self, hex_c):
        self.current_color = hex_c
        self.btn_color.setStyleSheet(f"background-color: {hex_c}; border-radius: 8px; border: none;")
        self.header_box.setStyleSheet(f"#ProjectBox {{ background-color: {hex_c}; border-radius: 4px; }}")
        self.setStyleSheet(f"#RowFrame {{ border: 3px solid {hex_c}; border-radius: 8px; background-color: white; }}")
        self.update_font_btn("black")

# --- 6. Main Window ---

CSV_FILE = "kanban_data.csv"

class KanbanBoard(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Dynamic Kanban Board v50")
        self.resize(1400, 800)
        
        main = QWidget()
        self.setCentralWidget(main)
        layout = QVBoxLayout(main)
        
        # Headers
        self.create_header(layout)
        
        # Scroll Area
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setStyleSheet("border: none; background: white;")
        layout.addWidget(scroll)
        
        self.scroll_content = QWidget()
        self.scroll_layout = QVBoxLayout(self.scroll_content)
        self.scroll_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        scroll.setWidget(self.scroll_content)

        # Footer
        footer = QWidget()
        flayout = QHBoxLayout(footer)
        
        btn_new = QPushButton("New Project")
        btn_new.setStyleSheet("background:#333; color:white; padding:10px; font-weight:bold;")
        btn_new.clicked.connect(lambda: self.add_project())
        
        btn_ref = QPushButton("Refresh")
        btn_ref.setStyleSheet("background:#333; color:white; padding:10px; font-weight:bold;")
        btn_ref.clicked.connect(self.refresh_all)

        btn_save = QPushButton("Save")
        btn_save.setStyleSheet("background:#333; color:white; padding:10px; font-weight:bold;")
        btn_save.clicked.connect(self.save_csv)

        flayout.addWidget(btn_new)
        flayout.addWidget(btn_ref)
        flayout.addWidget(btn_save)
        layout.addWidget(footer)

        self.load_csv()
        
        QTimer.singleShot(100, lambda: GLOBAL_SYNC.force_update())

    def create_header(self, layout):
        w = QWidget()
        l = QHBoxLayout(w)
        l.setContentsMargins(5,0,5,0)
        sp = QLabel("Project"); sp.setFixedWidth(200)
        sp.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sp.setStyleSheet("background:#E0E0E0; font-weight:bold; padding:10px; border-radius:5px;")
        
        splitter = QSplitter(Qt.Orientation.Horizontal)
        GLOBAL_SYNC.add_splitter(splitter)
        
        for t, c in [("Todo","#2196F3"), ("WIP","#FFC107"), ("Done","#4CAF50")]:
            lb = QLabel(t)
            lb.setAlignment(Qt.AlignmentFlag.AlignCenter)
            fg = "black" if t=="WIP" else "white"
            lb.setStyleSheet(f"background:{c}; color:{fg}; font-weight:bold; padding:10px; border-radius:5px;")
            splitter.addWidget(lb)
            
        l.addWidget(sp)
        l.addWidget(splitter)
        layout.addWidget(w)

    def add_project(self, name="New Project", color="#FFAB91", is_completed=False):
        row = ProjectRow(name, is_completed)
        if color: row.apply_theme(color)
        row.requestSave.connect(self.save_csv)
        row.requestDelete.connect(self.delete_row)
        
        count = self.scroll_layout.count()
        idx = count
        if count > 0:
            last_w = self.scroll_layout.itemAt(count-1).widget()
            if isinstance(last_w, ProjectRow) and last_w.is_completed:
                idx = count - 1
        if is_completed: idx = count

        self.scroll_layout.insertWidget(idx, row)
        return row

    def delete_row(self, row):
        GLOBAL_SYNC.remove_splitter(row.splitter)
        row.deleteLater()
        self.save_csv()

    def refresh_all(self):
        for i in range(self.scroll_layout.count()):
            w = self.scroll_layout.itemAt(i).widget()
            if isinstance(w, ProjectRow):
                for col in w.cols:
                     self.recursive_update_dates(col, col.invisibleRootItem())
        self.save_csv()

    def recursive_update_dates(self, tree, item):
        c = item.childCount()
        for i in range(c):
            self.recursive_update_dates(tree, item.child(i))
        if item is not tree.invisibleRootItem():
            tree.update_parent_dates(item)

    def save_csv(self):
        data = []
        for i in range(self.scroll_layout.count()):
            w = self.scroll_layout.itemAt(i).widget()
            if isinstance(w, ProjectRow):
                p_name = w.inp_name.text()
                p_col = w.current_color
                is_comp = w.is_completed
                
                for col in w.cols:
                    it = QTreeWidgetItemIterator(col)
                    while it.value():
                        item = it.value()
                        d = item.data(0, Qt.ItemDataRole.UserRole)
                        pid = ""
                        if item.parent():
                            pd = item.parent().data(0, Qt.ItemDataRole.UserRole)
                            pid = pd['id']
                        
                        row_data = d.copy()
                        row_data['project'] = p_name
                        row_data['project_color'] = p_col
                        row_data['is_completed_project'] = str(is_comp)
                        row_data['parent_id'] = pid
                        data.append(row_data)
                        it += 1
                
                if not data or data[-1]['project'] != p_name:
                     data.append({
                         'id': 'PROJECT_MARKER', 'project': p_name, 
                         'project_color': p_col, 'is_completed_project': str(is_comp)
                     })

        try:
            with open(CSV_FILE, 'w', newline='', encoding='utf-8') as f:
                fields = ['id','name','pic','priority','start','duration','end','stage',
                          'project','project_color','is_completed_project','parent_id']
                writer = csv.DictWriter(f, fieldnames=fields)
                writer.writeheader()
                for d in data:
                    out = {k: d.get(k,'') for k in fields}
                    writer.writerow(out)
        except Exception as e:
            print("Save failed:", e)

    def load_csv(self):
        while self.scroll_layout.count():
            item = self.scroll_layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()

        if not os.path.exists(CSV_FILE):
            self.add_project("Alpha Project")
            self.add_project("Completed", "#E0E0E0", True)
            return

        try:
            with open(CSV_FILE, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                rows = list(reader)
        except: return

        proj_map = {}
        created_names = []
        for r in rows:
            p_name = r['project']
            if p_name not in created_names:
                is_comp = (r.get('is_completed_project') == 'True')
                row = self.add_project(p_name, r.get('project_color'), is_comp)
                proj_map[p_name] = row
                created_names.append(p_name)

        item_map = {}
        orphan_list = [] 

        for r in rows:
            if r['id'] == 'PROJECT_MARKER': continue
            
            row = proj_map.get(r['project'])
            if not row: continue
            
            stage = r.get('stage', '1')
            tree = row.cols[0] 
            if stage == '1': tree = row.cols[0]
            elif stage == '2': tree = row.cols[1]
            elif stage == '3': tree = row.cols[2]
            
            data = {
                'id': r['id'], 'name': r['name'], 'pic': r['pic'],
                'priority': r['priority'], 'start': r['start'],
                'duration': r['duration'], 'end': r['end'],
                'stage': stage
            }
            
            item = QTreeWidgetItem()
            item.setData(0, Qt.ItemDataRole.UserRole, data)
            item_map[r['id']] = item
            
            pid = r.get('parent_id')
            if not pid:
                tree.addTopLevelItem(item)
                tree.create_widget(item, data, is_new=False)
                item.setExpanded(True)
            else:
                orphan_list.append((item, pid, tree, data))

        for item, pid, tree, data in orphan_list:
            if pid in item_map:
                parent = item_map[pid]
                parent.addChild(item)
                tree.create_widget(item, data, is_new=False)
                parent.setExpanded(True)
                item.setExpanded(True)
            else:
                tree.addTopLevelItem(item)
                tree.create_widget(item, data, is_new=False)

        QTimer.singleShot(100, lambda: GLOBAL_SYNC.force_update())

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = KanbanBoard()
    window.show()
    sys.exit(app.exec())
